package interaction.feedbackprovider.common;

import dmcontext.DMContext;
import interaction.feedbackprovider.FeedbackProvider;
import interaction.feedbackprovider.dm.DMResult;
import interaction.reference.Result;
import system.AbstractReport;
import system.dm.DM;
import utils.StringUtils;

import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;

/**
 * Wrapper for the all the feedback received (generated by {@link FeedbackProvider#generateFeedback(DMContext, DM[], Result)}).
 *
 * @author MTomczyk
 */


public class CommonResult extends AbstractReport
{

    /**
     * Parameterized constructor.
     *
     * @param dmContext current decision-making context
     * @param DMs decision makers' identifiers
     */
    public CommonResult(DMContext dmContext, DM [] DMs)
    {
        super(dmContext);
        _DMs = DMs;
    }

    /**
     * List of all registered decision makers.
     */
    protected final DM [] _DMs;

    /**
     * All feedback received.
     */
    public HashMap<DM, DMResult> _feedback = null;


    /**
     * Auxiliary method constructing the string representation of the result. Each line does not end with a new line
     * symbol and is stored in a different output array element.
     *
     * @return string representation
     */
    @Override
    public String[] getStringRepresentation()
    {
        return getStringRepresentation(0);
    }


    /**
     * Auxiliary method constructing the string representation of the result. Each line does not end with a new line
     * symbol and is stored in a different output array element.
     *
     * @param indent auxiliary indent used when constructing the lines
     * @return string representation
     */
    @SuppressWarnings("DuplicatedCode")
    @Override
    public String[] getStringRepresentation(int indent)
    {
        String ind = StringUtils.getIndent(indent);
        if (_DMs == null) return new String[]{ind + "No DMs are provided"};
        if (_feedback == null) return new String[]{ind + "Noo feedback is provided"};
        LinkedList<String> lines = new LinkedList<>();

        applyBasicLines(lines, ind);
        lines.add(ind + "Retrieving time = " + _processingTime + " ms");
        lines.add(ind + "Feedback retrieved:");
        boolean none = true;
        for (DM dm : _DMs)
        {
            if (!_feedback.containsKey(dm)) continue;
            none = false;
            String[] S = _feedback.get(dm).getStringRepresentation(indent + 2);
            lines.addAll(Arrays.asList(S));
        }
        if (none)
        {
            lines.add(ind + "  None");
        }

        return StringUtils.getArrayFromList(lines);
    }


}
