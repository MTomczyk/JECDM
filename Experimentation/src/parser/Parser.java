package parser;


import condition.ScenarioDisablingConditions;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Set;

/**
 * Supportive parser class that translates the input args provided via the command line. It allows customizing the
 * processing from the console.
 *
 * @author MTomczyk
 */
public class Parser
{
    /**
     * Class representing the results generated by the parser.
     */
    public static class Result
    {
        /**
         * This fields captures all arguments that were not successfully parsed.
         */
        public LinkedList<String> _invalidArgs;

        /**
         * Specifies the scenario disabling conditions.
         */
        public LinkedList<ScenarioDisablingConditions> _scenarioDisablingConditions;

        /**
         * Specifies the number of threads to be dispatched at the trial-level (should be greater than 0).
         */
        public Integer _noThreads;

        /**
         * Set containing IDs of those trials that are to be disabled.
         */
        public Set<Integer> _disabledTrials;

        /**
         * Default constructor.
         */
        public Result()
        {
            _invalidArgs = new LinkedList<>();
            _noThreads = null;
            _disabledTrials = null;
            _scenarioDisablingConditions = null;
        }

        /**
         * Auxiliary method that can be called to generate lines (strings) constituting a report on the data stored.
         *
         * @return log lines
         */
        public String[] generateLogLines()
        {
            LinkedList<String> logs = new LinkedList<>();
            if (_noThreads == null) logs.add("No. threads = not specified");
            else logs.add("No. threads = " + _noThreads);
            if ((_scenarioDisablingConditions == null) || (_scenarioDisablingConditions.isEmpty()))
                logs.add("Scenario disabling conditions = not specified");
            else
            {
                logs.add("Scenario disabling conditions =");
                for (ScenarioDisablingConditions sdc : _scenarioDisablingConditions) logs.add("   " + sdc.toString());
            }
            if ((_disabledTrials == null) || (_disabledTrials.isEmpty())) logs.add("Trial disabling conditions = not specified");
            else
            {
                StringBuilder s = new StringBuilder("Trial disabling conditions = ");
                int[] ids = new int[_disabledTrials.size()];
                int idx = 0;
                for (Integer id : _disabledTrials) ids[idx++] = id;
                for (int i = 0; i < ids.length; i++)
                {
                    s.append(ids[i]);
                    if (i < ids.length - 1) s.append(" ");
                }
                logs.add(s.toString());
            }
            if ((_invalidArgs == null) || (_invalidArgs.isEmpty())) logs.add("Invalid arguments = none");
            else
            {
                logs.add("Invalid arguments =");
                for (String s : _invalidArgs) logs.add("   " + s);
            }

            String[] r = new String[logs.size()];
            int idx = 0;
            for (String s : logs) r[idx++] = s;
            return r;
        }
    }

    /**
     * The main method for parsing the input args.
     *
     * @param args input arguments provided via the command line
     * @return parsing results
     */
    public Result parse(String[] args)
    {
        Result result = new Result();
        for (String arg : args)
        {
            if (arg == null) continue;
            process(result, arg);
        }
        return result;
    }

    /**
     * This method parses one input argument
     *
     * @param result result object (to be filled throughout processing)
     * @param arg    input argument (should not be null)
     */
    private void process(Result result, String arg)
    {
        String s = arg.replaceAll("\\s", ""); // remove white spaces
        s = s.toUpperCase(); // to upper case
        String[] kv = s.split("=");

        if (kv.length != 2)
        {
            if (!s.isEmpty()) result._invalidArgs.add(s);
            return;
        }

        switch (kv[0])
        {
            case "DISABLED_SCENARIOS" ->
            {
                if (!processDisableScenarios(result, kv[1])) result._invalidArgs.add(s);
            }
            case "DISABLED_TRIALS" ->
            {
                if (!processDisableTrials(result, kv[1])) result._invalidArgs.add(s);
            }
            case "THREADS" ->
            {
                if (!processNoThreads(result, kv[1])) result._invalidArgs.add(s);
            }
            default -> result._invalidArgs.add(s);
        }
    }

    /**
     * Processes the value parameter for the key = "DISABLE_SCENARIOS" (specifies which scenarios should be disabled).
     *
     * @param result result object (to be filled throughout processing)
     * @param value  value (string) linked to the key = "DISABLE_SCENARIOS"; it is expected to be in the following format:
     *               "[conditions separated by commas]", where each condition should be the following format:
     *               "(key-values separated by semicolons)", where (finally), each key-value is a pair of strings
     *               connected via the colon; the keys and values are used in {@link condition.ScenarioDisablingConditions}
     *               when examining existing scenarios; all invalid entries are skipped; example value:
     *               "[(PROBLEM:DTLZ2;ALGORITHM:NSGAII;OBJECTIVES:3),(OBJECTIVES:5)]"
     * @return true = parsing was successful, false otherwise
     */
    protected boolean processDisableScenarios(Result result, String value)
    {
        String s = getFromBrackets(value, '[', ']');
        if (s == null) return false;

        LinkedList<ScenarioDisablingConditions> SDC = null;

        String[] conditions = s.split(",");
        for (String condition : conditions)
        {
            String c = getFromBrackets(condition, '(', ')');
            if (c == null) continue;

            LinkedList<String> keys = new LinkedList<>();
            LinkedList<String> values = new LinkedList<>();

            String[] kvs = c.split(";");
            for (String kv : kvs)
            {
                if (!kv.contains(":")) continue;
                String[] skv = kv.split(":");
                if (skv.length != 2) continue;
                keys.add(skv[0]);
                values.add(skv[1]);
            }

            if (keys.isEmpty()) continue;

            String[] k = new String[keys.size()];
            String[] v = new String[values.size()];

            int idx = 0;
            ListIterator<String> kIt = keys.listIterator();
            ListIterator<String> vIt = values.listIterator();

            while ((kIt.hasNext()) && (vIt.hasNext()))
            {
                k[idx] = kIt.next();
                v[idx++] = vIt.next();
            }

            if (SDC == null) SDC = new LinkedList<>();
            SDC.add(new ScenarioDisablingConditions(k, v));
        }

        result._scenarioDisablingConditions = SDC;

        return true;
    }

    /**
     * Auxiliary method for deriving a substring wrapped via brackets with a specified format.
     *
     * @param leftBracket  left bracket
     * @param rightBracket right bracket
     * @param input        input string
     * @return substring of the input (returns null if the first and the last characters of the input are not [ and ])
     */
    private String getFromBrackets(String input, Character leftBracket, Character rightBracket)
    {
        if (input.length() < 2) return null;
        if (!leftBracket.equals(input.charAt(0))) return null;
        if (!rightBracket.equals(input.charAt(input.length() - 1))) return null;
        return input.substring(1, input.length() - 1);
    }

    /**
     * Processes the value parameter for the key = "DISABLE_TRIALS" (specifies which trials should be disabled).
     *
     * @param result result object (to be filled throughout processing)
     * @param value  value (string) linked to the key = "DISABLE_TRIALS"; the value is expected to be provided in the
     *               following format: "[integers separated by commas]", note that the closed intervals in the form of
     *               value1-value2 are also allowed; example valid value: "[0, 1, 2, 10-25]"; all the invalid entries
     *               are skipped
     * @return true = parsing was successful, false otherwise
     */
    protected boolean processDisableTrials(Result result, String value)
    {
        String s = getFromBrackets(value, '[', ']');
        if (s == null) return false;

        String[] ids = s.split(",");
        Set<Integer> disabledFlags = new HashSet<>(100);

        for (String v : ids)
        {
            if (v.contains("-"))
            {
                String[] lr = v.split("-");
                if (lr.length != 2) continue;
                int left;
                int right;

                try
                {
                    left = Integer.parseInt(lr[0]);
                } catch (NumberFormatException e)
                {
                    continue;
                }

                try
                {
                    right = Integer.parseInt(lr[1]);
                } catch (NumberFormatException e)
                {
                    continue;
                }
                if (left > right) continue;
                for (int i = left; i <= right; i++) disabledFlags.add(i);
            }
            else
            {
                try
                {
                    int id = Integer.parseInt(v);
                    disabledFlags.add(id);
                } catch (NumberFormatException ignored)
                {
                }
            }
        }

        if (!disabledFlags.isEmpty()) result._disabledTrials = disabledFlags;
        return true;
    }

    /**
     * Processes the value parameter for the key = "THREADS" (specifies the number of threads that should be used during
     * trial-level processing).
     *
     * @param result result object (to be filled throughout processing)
     * @param value  value (string) linked to the key = "THREADS"; it is expected that it is an integer > 0
     * @return true = parsing was successful, false otherwise
     */
    protected boolean processNoThreads(Result result, String value)
    {
        try
        {
            result._noThreads = Integer.parseInt(value);
        } catch (NumberFormatException e)
        {
            result._noThreads = null;
            return false;
        }
        return true;
    }
}
