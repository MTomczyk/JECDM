package tools.feedbackgenerators;

import alternative.Alternative;
import exception.Exception;
import exception.GlobalException;
import model.internals.value.AbstractValueInternalModel;
import scenario.KeyValue;
import scenario.KeyValues;
import scenario.Scenario;
import space.Range;
import space.normalization.INormalization;
import space.os.ObjectiveSpace;
import utils.Level;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

/**
 * Data loader for the data on pairwise comparisons generated by {@link PCsDataGenerator}
 *
 * @author MTomczyk
 */
public final class PCsDataLoader extends AbstractPCsData
{
    /**
     * Params container.
     */
    public static final class Params extends AbstractPCsData.Params
    {
        /**
         * Model reader parser.
         */
        public IDMModelReaderParser _modelReader;

        /**
         * Alternative reader parser.
         */
        public IAlternativeReaderParser _alternativeReader;

        /**
         * Default constructor.
         */
        public Params()
        {

        }

        /**
         * Parameterized constructor.
         *
         * @param pp field values are copied from this input params container (references)
         */
        public Params(AbstractPCsData.Params pp)
        {
            _keys = pp._keys;
            _values = pp._values;
            _extraAllowedCharacters = pp._extraAllowedCharacters;
            _trials = pp._trials;
            _noInteractionsProvider = pp._noInteractionsProvider;
            _filePath = pp._filePath;
            _indent = pp._indent;
            _notify = pp._notify;
        }
    }

    /**
     * Parameterized constructor.
     *
     * @param p params container
     * @throws Exception exception can be thrown 
     */
    public PCsDataLoader(Params p) throws Exception
    {
        super(p);
        validate(p);
        _modelReader = p._modelReader;
        _alternativeReader = p._alternativeReader;
    }

    /**
     * Model reader parser.
     */
    private final IDMModelReaderParser _modelReader;

    /**
     * Alternative reader parser.
     */
    private final IAlternativeReaderParser _alternativeReader;

    /**
     * Parses the line into the scenario object
     *
     * @param SL header line
     * @return scenario object
     * @throws Exception can be thrown 
     */
    private Scenario getScenario(String SL) throws Exception
    {
        try
        {
            String[] s = SL.split("_");
            KeyValue[] kvs = new KeyValue[_keys.length];
            int off = 0;
            for (int i = 0; i < _keys.length; i++)
            {
                KeyValues kv = KeyValues.getInstance(s[off], s[off + 1]);
                kvs[i] = new KeyValue(kv.getKey(), kv.getValues()[0]);
                off += 2;
            }
            return _scenarios.getScenariosThatMatch(kvs)[0]; // must be exactly one match
        } catch (GlobalException e)
        {
            throw new Exception("Exception was caught when parsing scenarios data (message = " + e.getMessage()
                    + ")", null, this.getClass());
        }
    }

    /**
     * This method executes the processing and stores the results in the suitable container.
     *
     * @return data container that stores the loading results
     * @throws Exception the exception can be thrown 
     */
    public FeedbackData process() throws Exception
    {
        if (_notify) _log.log("Processing started", Level.Global, 0);
        if (_notify) _log.log("Attempting to load the file = " + _filePath, Level.Global, 0);

        if (_notify) _log.log("Instantiating feedback data object", Level.Global, 0);
        FeedbackData feedbackData = new FeedbackData(_scenarios);

        String V;
        String[] tmp;

        try (BufferedReader r = new BufferedReader(new FileReader(_filePath)))
        {
            for (int s = 0; s < _scenarios.getScenarios().length; s++)
            {
                if ((_scenarioDisablingConditions != null) &&
                        (_scenarioDisablingConditions.shouldBeDisabled(_scenarios.getScenarios()[s])))
                {
                    if (_notify)
                        _log.log("Skipping processing scenario = " + _scenarios.getScenarios()[s], Level.Global, 0);
                    continue;
                }

                String SL = r.readLine(); // skipped scenarios are not read
                Scenario scenario = getScenario(SL);
                if (_notify) _log.log("Processing scenario = " + scenario, Level.Global, 0);
                // Check scenario disabling conditions

                int noInteractions = _noInteractionsProvider.getNoInteractions(scenario);

                if (_notify) _log.log("Parsing ranges", Level.Global, 0);

                String RL = r.readLine();
                Range[] ranges = null;
                { // parse ranges
                    int noRanges;
                    V = getValueSubstring(RL);
                    if (V != null)
                    {
                        noRanges = Integer.parseInt(V);
                        if (noRanges != 0) ranges = new Range[noRanges];
                        for (int i = 0; i < noRanges; i++)
                        {
                            String R = r.readLine(); // read ranges data
                            V = getValueSubstring(R);
                            if (V != null)
                            {
                                tmp = V.split(" ");
                                ranges[i] = new Range(Double.parseDouble(tmp[0]), Double.parseDouble(tmp[1]));
                            }
                        }
                    }
                }

                if (_notify) _log.log("Parsing criteria types", Level.Global, 0);

                String CL = r.readLine();
                boolean[] criteriaTypes = null;
                { // parse criteria types
                    int noCriteriaTypes;
                    V = getValueSubstring(CL);
                    if (V != null)
                    {
                        noCriteriaTypes = Integer.parseInt(V);
                        if (noCriteriaTypes != 0) criteriaTypes = new boolean[noCriteriaTypes];
                        for (int i = 0; i < noCriteriaTypes; i++)
                        {
                            String R = r.readLine(); // read ranges data
                            V = getValueSubstring(R);
                            if (V != null) criteriaTypes[i] = Boolean.parseBoolean(V);
                        }
                    }
                }

                if (_notify) _log.log("Building normalizations", Level.Global, 0);

                INormalization[] normalizations = null;
                if ((ranges != null) && (criteriaTypes != null))
                {
                    ObjectiveSpace os = new ObjectiveSpace(ranges, criteriaTypes);
                    normalizations = _normalizationsBuilder.getNormalizations(os);
                }


                // Trial-related data
                FeedbackData.TrialData[] TDs = new FeedbackData.TrialData[_trials];

                if (_notify) _log.log("Processing trials started", Level.Global, _indent);


                // read trials data
                for (int t = 0; t < _trials; t++)
                {
                    if (_notify) _log.log("Processing trial = " + t, Level.Global, _dIndent);

                    // Interactions-related data
                    FeedbackData.InteractionData[] interactionData = new FeedbackData.InteractionData[noInteractions];

                    int trialID = -1;
                    String TH = r.readLine(); // trial header
                    {
                        V = getValueSubstring(TH);
                        if (V != null) trialID = Integer.parseInt(V);
                    }

                    if (_notify) _log.log("Parsing artificial DM's model", Level.Global, _dIndent);

                    String DMH = r.readLine(); // DM header
                    AbstractValueInternalModel model = _modelReader.parseFromString(scenario, normalizations, DMH);
                    if (model == null)
                        throw new Exception("The model of an artificial DM was not parsed successfully", null, this.getClass());

                    if (_notify) _log.log("Parsing pairwise comparisons", Level.Global, _dIndent);

                    for (int pc = 0; pc < noInteractions; pc++)
                    {
                        int interactionNo = -1;
                        String IH = r.readLine(); // Interaction header
                        V = getValueSubstring(IH);
                        if (V != null) interactionNo = Integer.parseInt(V);

                        //noinspection DuplicatedCode
                        r.readLine(); // A1 header (name)
                        String A1S = r.readLine(); // A1 state // not used
                        A1S = getValueSubstring(A1S);

                        String A1E = r.readLine();
                        Alternative A1 = _alternativeReader.parseFromString(A1E);
                        if (A1 == null)
                            throw new Exception("Could not parse an alternative from a line", null, this.getClass());

                        //noinspection DuplicatedCode
                        r.readLine(); // A1 header
                        String A2S = r.readLine(); // A1 state
                        A2S = getValueSubstring(A2S);

                        String A2E = r.readLine(); // A1 to parse
                        Alternative A2 = _alternativeReader.parseFromString(A2E);
                        if (A2 == null)
                            throw new Exception("Could not parse an alternative from a line", null, this.getClass());

                        validatePC(model, A1S, A1, A2S, A2);

                        interactionData[pc] = new FeedbackData.InteractionData(interactionNo, new Alternative[]{A1, A2});
                    }

                    TDs[t] = new FeedbackData.TrialData(trialID, model, interactionData);
                }

                if (_notify) _log.log("Processing trials ended", Level.Global, _indent);

                // Fill data:
                FeedbackData.ScenarioData SD = new FeedbackData.ScenarioData(scenario, ranges, TDs);
                feedbackData.addData(SD);
            }

            if (_notify) _log.log("Processing ended", Level.Global, 0);
            return feedbackData;

        } catch (IOException e)
        {
            throw new Exception("Error occurred when processing the results file (message = " +
                    e.getMessage() + ")", null, this.getClass());
        }
    }

    /**
     * Auxiliary method for verifying data consistency (on pairwise comparison).
     *
     * @param model  current DM's model
     * @param state1 the first alternative's state
     * @param A1     the first alternative
     * @param state2 the second alternative's state
     * @param A2     the second alternative
     * @throws Exception exception can be thrown 
     */
    private void validatePC(AbstractValueInternalModel model, String state1, Alternative A1, String state2, Alternative A2) throws Exception
    {
        double e1 = model.evaluate(A1);
        double e2 = model.evaluate(A2);
        int comp = Double.compare(e1, e2);

        if (comp == 0)
        {
            if ((!state1.equals(PreferenceStates.EQUAL.toString())) || (!state2.equals(PreferenceStates.EQUAL.toString())))
            {
                throw new Exception("Alternatives are equally evaluated but the states are " + state1 + " and " + state2,
                        null, this.getClass());
            }
        }
        else if (((comp < 0) && (model.isLessPreferred())) || ((comp > 0) && (!model.isLessPreferred())))
        {
            if ((!state1.equals(PreferenceStates.PREFERRED.toString())) || (!state2.equals(PreferenceStates.NOT_PREFERRED.toString())))
            {
                throw new Exception("Alternative " + A1.getName() + " should be indicated as preferred (but is " + state1 + "), " +
                        "while alternative " + A2.getName() + " should be not preferred (but is " + state2 + ")",
                        null, this.getClass());
            }
        }
        else
        {
            if ((!state1.equals(PreferenceStates.NOT_PREFERRED.toString())) || (!state2.equals(PreferenceStates.PREFERRED.toString())))
            {
                throw new Exception("Alternative " + A1.getName() + " should be indicated as not preferred (but is " + state1 + "), " +
                        "while alternative " + A2.getName() + " should be preferred (but is " + state2 + ")",
                        null, this.getClass());
            }
        }
    }

    /**
     * Returns a substring that is wrapped by quotation marks.
     *
     * @param line line to be parsed
     * @return value (null, if the line cannot be parsed)
     */
    private String getValueSubstring(String line)
    {
        int l = line.indexOf('\"');
        int r = line.indexOf('\"', l + 1);
        if (l < 0) return null;
        if (r < 0) return null;
        l++;
        if (l >= r) return null;
        return line.substring(l, r);
    }

    /**
     * Auxiliary method for validating params container's data.
     *
     * @param p params container
     * @throws Exception exception can be thrown 
     */
    private void validate(Params p) throws Exception
    {
        if (p._modelReader == null)
            throw new Exception("The artificial DM's model reader is null", null, this.getClass());
        if (p._alternativeReader == null)
            throw new Exception("The alternative reader is null", null, this.getClass());
    }
}
