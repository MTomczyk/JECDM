package combinatorics;

/**
 * This class provides methods related to generating possible outcomes (task-specific).
 *
 * @author MTomczyk
 */


public class Possibilities
{
    /**
     * This method generates a Cartesian Product of n-sets. The sets' values are irrelevant, but their sizes are.
     * The result is represented as a matrix, where each row is a unique vector of n-indices pointing to different
     * elements of n sets. Each row is generated by incrementing the first element and checking whether the capacity is
     * exceeded (if so, the next value in the array will be increased, and so on).
     *
     * @param s n-element array representing sizes of n sets
     * @return matrix, where each row is a unique vector of n-indices pointing to different elements of n sets
     */
    public static int[][] generateCartesianProduct(int[] s)
    {
        return generateCartesianProduct(s, false);
    }

    /**
     * This method generates a Cartesian Product of n-sets. The sets' values are irrelevant, but their sizes are.
     * The result is represented as a matrix, where each row is a unique vector of n-indices pointing to different
     * elements of n sets. Each row is generated by incrementing the first element and checking whether the capacity is
     * exceeded (if so, the next value in the array will be increased, and so on).
     *
     * @param s                  n-element array representing sizes of n sets
     * @param incrementFromRight if true, the incrementation starts from the last index; false = starts from the first index
     * @return matrix, where each row is a unique vector of n-indices pointing to different elements of n sets
     */
    public static int[][] generateCartesianProduct(int[] s, boolean incrementFromRight)
    {
        int t = 1;
        for (int e : s) t *= e;
        int[][] r = new int[t][s.length];

        int sindex = 0;
        int shift = 1;

        if (incrementFromRight)
        {
            sindex = s.length - 1;
            shift = -1;
        }

        int cindex;

        for (int it = 1; it < t; it++)
        {
            System.arraycopy(r[it - 1], 0, r[it], 0, s.length); // copy
            cindex = sindex;

            while (r[it][cindex] + 1 == s[cindex])
            {
                r[it][cindex] = 0;
                cindex += shift;
            }
            r[it][cindex]++;
        }

        return r;
    }
}
